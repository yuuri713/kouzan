<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>営業時間</title>

  <!-- Shippori Mincho -->
  <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --fg:#fff; --sub-fg:#fff;

      /* 既定のサイズ（URLで上書き可） */
      --fs-status:18px;   /* PC 上段 */
      --fs-hours:18px;    /* PC 下段 */
      --fs-status-sp:16px;/* SP 上段 */
      --fs-hours-sp:16px; /* SP 下段 */
    }

    html, body{
      margin:0; padding:0;
      background:transparent;
      color:var(--fg);
      font-family:'Shippori Mincho', serif;
    }

    /* iframe内ラッパー */
    .wrap{
      margin:0; padding:0;
      line-height:1.9;
      display:flex; flex-direction:column;
      justify-content:center;
      white-space:nowrap; /* 1行を保つ */
      align-items:flex-start; /* 既定は左寄せ */
      text-align:left;
    }

    /* 上段（見出し） */
    #status{
      font-size:var(--fs-status);
      font-weight:600;
      letter-spacing:.12em;
    }

    /* 下段（営業時間） */
    #hours{
      margin-top:.4em;
      font-size:var(--fs-hours);
      color:var(--sub-fg);
      letter-spacing:.2em;
    }

    /* スマホ */
    @media (max-width:480px){
      #status{ font-size:var(--fs-status-sp); }
      #hours { font-size:var(--fs-hours-sp); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="status">読み込み中…</div>
    <div id="hours"></div>
  </div>

  <!-- サイズ・整列制御（?size=xs|sm|md / ?pc=16,16&sp=14,14） -->
  <script>
    (function(){
      const r = document.documentElement;
      const q = new URLSearchParams(location.search);
      const wrap = document.querySelector('.wrap');

      // プリセット
      const PRESET = {
        xs: { pc:[14,14], sp:[12,12] },
        sm: { pc:[14,14], sp:[14,14] },
        md: { pc:[16,16], sp:[16,16] }
      };

      // ?size=xs|sm|md
      const size = q.get('size');
      if (size && PRESET[size]) {
        const {pc, sp} = PRESET[size];
        r.style.setProperty('--fs-status', pc[0] + 'px');
        r.style.setProperty('--fs-hours',  pc[1] + 'px');
        r.style.setProperty('--fs-status-sp', sp[0] + 'px');
        r.style.setProperty('--fs-hours-sp',  sp[1] + 'px');

        // xs のときだけ中央寄せ
        if (size === 'xs' && wrap) {
          wrap.style.alignItems = 'center';
          wrap.style.textAlign = 'center';
        }
      }

      // 直接指定 ?pc=16,16&sp=14,14
      const pc = q.get('pc');
      const sp = q.get('sp');
      if (pc) {
        const [s,h] = pc.split(',').map(n => parseInt(n,10));
        if (!isNaN(s)) r.style.setProperty('--fs-status', s + 'px');
        if (!isNaN(h)) r.style.setProperty('--fs-hours',  h + 'px');
      }
      if (sp) {
        const [s,h] = sp.split(',').map(n => parseInt(n,10));
        if (!isNaN(s)) r.style.setProperty('--fs-status-sp', s + 'px');
        if (!isNaN(h)) r.style.setProperty('--fs-hours-sp',  h + 'px');
      }
    })();
  </script>

  <!-- 言語切替付きリアルタイム表示（v1/v0 JSON 両対応） -->
  <script>
  const JSON_URL = './opening-hours.json';
  const REFRESH_MS = 30000;
  const LANG = new URLSearchParams(location.search).get('lang') || 'ja';
  const T = {
    ja: {
      OPEN: 'ただいま、営業しております',
      BREAK: (t) => `ただいま、休憩中です（${t}〜再開）`,
      PREP: 'ただいま、準備中です',
      FINISH: '本日の営業は終了しました',
      HOLIDAY: '本日は定休日です',
      HOURS: '営業時間',
      TODAY_HOURS: '本日の営業時間',
      TOMORROW_HOURS: '明日の営業時間',
      TOMORROW_CLOSED: '明日は定休日です',
      FAIL: '現在、営業時間を取得できません',
      RETRY: '時間をおいて再読み込みしてください'
    },
    en: {
      OPEN: 'We are open now',
      BREAK: (t) => `We are on a break (resumes at ${t})`,
      PREP: 'Getting ready',
      FINISH: 'Today’s business has ended',
      HOLIDAY: 'Closed today',
      HOURS: 'Business hours',
      TODAY_HOURS: 'Today’s hours',
      TOMORROW_HOURS: 'Tomorrow’s hours',
      TOMORROW_CLOSED: 'Closed tomorrow',
      FAIL: 'Unable to load hours',
      RETRY: 'Please try reloading later'
    }
  }[LANG];

  /* ---------- helpers（v1/v0 両対応） ---------- */

  // HHMM を "HH:MM" に整形（いろんな形を受け取って正規化）
  function hmPretty(hhmm){
    if (hhmm == null) return '';
    // "HH:MM"
    if (/^\d{2}:\d{2}$/.test(String(hhmm))) return String(hhmm);
    // number or "HHMM"
    const s = String(hhmm).replace(':','').padStart(4,'0');
    if (/^\d{4}$/.test(s)) return `${s.slice(0,2)}:${s.slice(2,4)}`;
    return '';
  }
  const toHMnum = (hm) => Number(hm.replace(':',''));
  const fmtHM = (h, m) => `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
  const nowInJST = (offset = 540) =>
    new Date(new Date().getTime() + (offset - new Date().getTimezoneOffset()) * 60000);

  // v1/v0 どちらのノードでも HHMM を取り出す
  function getHHMMfromNode(node){
    if (!node) return null;
    // v0: { time: "1100" }
    if (typeof node.time === 'string' && node.time.length >= 3) return node.time;

    // v1: { hour, minute } or { hours, minutes }
    const h = node.hour ?? node.hours;
    const m = node.minute ?? node.minutes ?? 0;
    if (Number.isInteger(h)) return `${String(h).padStart(2,'0')}${String(m).padStart(2,'0')}`;

    // v1別形: { startTime: "11:00" } / { endTime: "14:30" }
    if (typeof node.startTime === 'string') return node.startTime.replace(':','');
    if (typeof node.endTime   === 'string') return node.endTime.replace(':','');

    // 文字列 "11:00" / 数字 1100 直接渡し
    if (typeof node === 'string') return node.replace(':','');
    if (typeof node === 'number') return String(node);

    return null;
  }

  // periods → 指定曜日(0:日〜6:土)のスロット抽出（深夜跨ぎも吸収）
  // v1(openDay/openTime/closeDay/closeTime) / v0(open/day/time, close/...) 両対応
  function extractDaySlots(periods = [], gday){
    const slots = [];
    for (const p of periods) {
      let oDay = p.openDay, cDay = p.closeDay;
      let oHHMM = null,     cHHMM = null;

      // v1 の時間フィールド
      if (p.openTime || p.closeTime) {
        oHHMM = getHHMMfromNode(p.openTime);
        cHHMM = getHHMMfromNode(p.closeTime);
      }

      // v0 / フォールバック
      const o = p.open ?? p.opens ?? p.start ?? p;
      const c = p.close ?? p.closes ?? p.end   ?? p;
      if (oDay === undefined) oDay = o?.day ?? o?.openDay ?? p?.day;
      if (cDay === undefined) cDay = c?.day ?? c?.closeDay ?? p?.day;
      if (!oHHMM) oHHMM = getHHMMfromNode(o);
      if (!cHHMM) cHHMM = getHHMMfromNode(c);

      // 欠けているものがあればスキップ
      if (typeof oDay !== 'number' || typeof cDay !== 'number' || !oHHMM || !cHHMM) continue;

      const oTime = hmPretty(oHHMM);
      const cTime = hmPretty(cHHMM);

      // 同日
      if (oDay === gday && cDay === gday) {
        slots.push({ start: oTime, end: cTime });
        continue;
      }
      // 当日→翌日
      if (oDay === gday && cDay === ((gday + 1) % 7)) {
        slots.push({ start: oTime, end: '23:59' });
        continue;
      }
      // 前日→当日（0時台クローズ）
      const prev = (gday + 6) % 7;
      if (oDay === prev && cDay === gday) {
        slots.push({ start: '00:00', end: cTime });
        continue;
      }
    }
    return slots.sort((a,b)=>a.start.localeCompare(b.start));
  }

  function calcStatus(slots, jstDate){
    if (!slots?.length) return { state: '定休日' };
    const cur = toHMnum(fmtHM(jstDate.getHours(), jstDate.getMinutes()));
    for (const s of slots) {
      const st = toHMnum(s.start), ed = toHMnum(s.end);
      if (st <= cur && cur < ed) return { state: '営業中', current: s };
    }
    const starts = slots.map(s => toHMnum(s.start));
    const ends   = slots.map(s => toHMnum(s.end));
    const nextOpen = starts.find(st => cur < st);
    if (nextOpen !== undefined) {
      const hadPrev = ends.some(ed => ed <= cur);
      return { state: hadPrev ? '休憩中' : '準備中', nextOpen };
    }
    return { state: '準備中', finishedToday: true };
  }

  const formatSlots = (slots=[]) => slots.map(s => `${s.start}–${s.end}`).join(' / ');

  function normalize(json){
    const periods =
      json?.regularOpeningHours?.periods ||
      json?.currentOpeningHours?.periods ||
      json?.result?.opening_hours?.periods ||
      [];

    const offset = json?.utcOffsetMinutes ?? 540;
    const jstNow = nowInJST(offset);
    const gToday = jstNow.getDay();
    const gTomorrow = (gToday + 1) % 7;

    const todaySlots    = extractDaySlots(periods, gToday);
    const tomorrowSlots = extractDaySlots(periods, gTomorrow);

    return {
      utcOffsetMinutes: offset,
      today:    { gDay:gToday,    slots:todaySlots,    isClosed: todaySlots.length===0 },
      tomorrow:{ gDay:gTomorrow,  slots:tomorrowSlots, isClosed: tomorrowSlots.length===0 },
    };
  }

  function render(jsonRaw){
    const statusEl = document.getElementById('status');
    const hoursEl  = document.getElementById('hours');

    if (!jsonRaw) {
      statusEl.textContent = T.FAIL;
      hoursEl.textContent  = T.RETRY;
      return;
    }

    const data = normalize(jsonRaw);
    const jstNow = nowInJST(data.utcOffsetMinutes);
    const slots  = data.today.slots || [];
    const st     = calcStatus(slots, jstNow);

    let headline = '';
    let subline  = '';

    if (st.state === '営業中') {
      headline = T.OPEN;
      subline  = `${T.HOURS}　${formatSlots(slots)}`;

    } else if (st.state === '休憩中') {
      const next = String(st.nextOpen).padStart(4,'0').replace(/(..)(..)/,'$1:$2');
      headline = T.BREAK(next);
      subline  = `${T.TODAY_HOURS}　${formatSlots(slots)}`;

    } else if (st.state === '準備中') {
      if (st.finishedToday) {
        headline = T.FINISH;
        const ts = data?.tomorrow?.slots || [];
        subline  = ts.length ? `${T.TOMORROW_HOURS}　${formatSlots(ts)}`
                             : T.TOMORROW_CLOSED;
      } else {
        headline = T.PREP;
        subline  = `${T.TODAY_HOURS}　${formatSlots(slots)}`;
      }

    } else { // 定休日
      headline = T.HOLIDAY;
      const ts = data?.tomorrow?.slots || [];
      subline  = ts.length ? `${T.TOMORROW_HOURS}　${formatSlots(ts)}`
                           : T.TOMORROW_CLOSED;
    }

    statusEl.textContent = headline;
    hoursEl.textContent  = subline;
  }

  async function loadJSON(){
    const url = `${JSON_URL}${JSON_URL.includes('?') ? '&' : '?'}v=${Date.now()}`;
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`opening-hours.json fetch failed: ${res.status}`);
    const text = await res.text();
    try {
      return JSON.parse(text);
    } catch (e) {
      console.error('JSON parse error. Response was:\n', text);
      throw e;
    }
  }

  async function boot(){
    try {
      const json = await loadJSON();
      render(json);
      setInterval(async () => {
        try {
          const j = await loadJSON();
          render(j);
        } catch (e) {
          console.error('periodic reload failed:', e);
        }
      }, REFRESH_MS);
    } catch (e) {
      console.error('boot error:', e);
      document.getElementById('status').textContent = T.FAIL;
      document.getElementById('hours').textContent  = T.RETRY;
    }
  }
  boot();
  </script>
</body>
</html>